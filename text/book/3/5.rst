تشخیص دور داشتن گراف جهت دار
==========================================================
مقدمه
------------------------------------------------
در بخش های قبلی, گاهی لازم می‌شد تشخیص دهیم یک گراف جهت دار دور دارد یا نه! برای مثال برای اینکه یک ترتیب توپولوژیک از گراف ارائه دهیم, ابتدا باید ببینیم گراف دور دارد یا نه. زیرا گرافی که دور دارد, هیچ ترتیب توپولوژیکی ندارد!

در اینجا به شرح دو الگوریتم می‌پردازیم که می‌توانند دوری بودن گراف را تشخیص دهند. از طرفی در الگوریتم اول, یک دور در گراف خروجی می‌دهیم!


الگوریتم کان (kahn)
------------------------------------------------
روش دیگری برای فهمیدن اینکه یک گراف دور دارد یا نه, الگوریتم کان است. این الگوریتم بر پایه استقرا عمل می‌کند. این روش با قضیه 3.3.2 بسیار شبیه هستند!

الگوریتم به اینصورت است که در ابتدا یک مجموعه خالی از راس ها داریم که آن را 
:math:`zero`
می‌نامیم. این مجموعه, مجموعه راس هایی هست که در گراف کنونی درجه ورودی‌شان 0 است.

در ابتدا, راس هایی که درجه ورودی‌شان 0 است را به 
:math:`zero`
اضافه می‌کنیم.

در هر مرحله, مجموعه راس هایی که در 
:math:`zero`
هستند را به همراه یال‌هایشان از گراف حذف می‌کنیم و به دنبال این‌کار, ممکن است یک سری راس جدید درجه ورودی‌شان 0 شود و به 
:math:`zero`
اضافه شوند. این‌کار را آنقدر ادامه می‌دهیم تا یا تعداد راس های گراف برابر با 0 شود و یا اینکه مجموعه 
:math:`zero`
خالی شود.

اگر در یک مرحله اندازه مجموعه
:math:`zero`
برابر با 0 بود و گراف کنونی هنوز شامل تعدادی راس بود, آنگاه گراف حتما دور دارد و اگر این اتفاق نیفتاد و همه راس ها از گراف حذف شدند, آنگاه گراف دور ندارد.

اثبات درستی الگوریتم
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
برای اثبات الگوریتم دو حالت از گراف را در نظر می‌گیریم. ابتدا فرض کنید گراف 
:math:`G`
دور داشته باشد, آنگاه ادعا می‌کنیم الگوریتم به درستی دور داشتن را تشخیص می‌دهد.

اگر 
:math:`G`
دور داشته باشد, آنگاه اگر این دور را 
:math:`C`
بنامیم, هیچکدام از راس های
:math:`C`
هیچگاه به 
:math:`zero`
اضافه نمی‌شوند(چرا؟). پس به جایی می‌رسیم که گراف هنوز شامل تعدادی راس است, اما 
:math:`zero`
خالی است! پس الگوریتم دور داشتن را تشخیص می‌دهد.

حال اگر گراف دور نداشته باشد, با استقرا روی تعداد راس ها ثابت می‌کنیم که همه راس ها حذف می‌شوند!

اولا که اگر گراف دور نداشته باشد, طبق قضیه 3.1.3 تعداد راس در گراف
:math:`G`
هستند که دردجه ورودی‌شان 0 است. پس این راس ها به مجموعه 
:math:`zero`
اضافه می‌شوند, سپس به همراه یال‌هایشان از گراف حذف می‌شوند. پس تعداد راس ها کم شد. از طرفی شرایط استقرا برقرار است و گراف کنونی دور ندارد. پس طبق استقرا همه راس ها از گراف حذف ‌می‌شوند و الگوریتم به درستی دور نداشتن را تشخیص می‌دهد.

پیچیدگی الگوریتم
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
برای بررسی پیچیدگی الگوریتم, باید ببینیم که روی راس ها و یال ها چه مقدار پیمایش کردیم. ما زمانی روی یال ها پیمایش می‌کنیم که راسی در مجموعه
:math:`zero`
باشد, آنگاه روی یال های مجاور آن راس پیمایش می‌کنیم. از طرفی هر راس فقط یکبار در
:math:`zero`
می‌آید و پس از آن از گراف حذف می‌شود. پس ما روی هر یال یکبار پیمایش میکنیم.

از طرفی هنگامی روی راس ها پیمایش میکنیم که  راس در مجموعه
:math:`zero`
قرار گیرد. و مشابها, هر راس فقط یک بار به این مجموعه اضافه می‌شود و پس از آن از گراف حذف می‌شود.

پس پیچیدگی الگوریتم بالا برابر است با
:math:`O(n + m)`
است که مشابه با الگوریتم قبلی است!

پیاده‌سازی الگوریتم
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: cpp

	#include <bits/stdc++.h>

	using namespace std;

	const int maxn = 5e5 + 5;

	int n, m; // tedad ras ha va yal ha
	int in_edge[maxn]; // in_edge[v] daraje vorodi rase v hast!

	vector<int> g[maxn]; // vector e mojaverat
	vector<int> zero; // ras haie ke daraje vorodi 0 daran va baiad hazf shan!

	bool has_cycle(){
	      for(int i = 0; i < n; i++){
		    if(in_edge[i] == 0){
			  zero.push_back(i); 
		    }	   
	      }
	      
	      for(int i = 0; i < n; i++) {
		    if(zero.size() == 0){
			  return true;
		    }

		    int v = zero[zero.size() - 1]; // ozve akhar az remove_set
		    zero.pop_back();
		    
		    for(int u : g[v]){
			  in_edge[u]--;
			  if(in_edge[u] == 0){
				zero.push_back(u);
			  }
		    }
	      }

	      return false;
	}


	int main(){
	      cin >> n >> m;
	      for(int i = 0; i < m; i++){
		    int u, v;
		    cin >> u >> v; // u, v 0-based hastan
		    g[u].push_back(v);
		    in_edge[v]++; // yale (u, v) dar graph ast. pas daraje vorodi v yeki ziad mishe!
	      }

	      if(has_cycle()){
		    cout << "graph has at least one cycle!" << endl;	    
	      } else {
		    cout << "graph is acyclic!" << endl;
	      }
	      
	      return 0;
	}


