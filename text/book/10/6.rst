درخت مجازی
===============

یک درخت مثل
:math:`T`
را در نظر بگیرید. یک زیر مجموعه دلخواه از راس های 
:math:`T`
مثل
:math:`A`
نسبت را درخت مجازی گوییم اگر نسبت به 
LCA
بسته باشد. یعنی
LCA
هر دو راس دلخواه از
:math:`A`
درون خود
:math:`A`
باشد.

چرا درخت مجازی برای ما مهم است؟
----------------

اولین مسئله
~~~~~~~~~~~~~~

 فرض کنید زیرمجموعه ای از راس های درخت مثل 
:math:`B`
را سیاه کرده ایم. حالا می خواهیم تعدادی از راس هایی که سیاه نیستند را نیز سیاه کنیم به طوریکه کل راس های سیاه همبند باشند. 
همچنین می خواهیم تعداد راس های سیاه در نهایت کمینه شوند. این کمینه تعداد را بیابید.

واضح است که برای حل این سوال باید تمام راس هایی که بر روی مسیر حداقل دو راس سیاه هستند را سیاه کنیم. اما سوال مهم این است که چطور تعداد این راس ها را بیابیم
به طوریکه پیچیدگی زمانی ما به
:math:`|B|`
مربوط باشد و کاملا مستقل از
:math:`n`
باشد. (یعنی اگر مجموعه‌ای که به ما دادند کوچک بود ما هم سریع جواب بدهیم و برعکس)

فرض کنید عدد جواب
:math:`ans`
باشد. توجه کنید که خود 
:math:`ans`
ممکن است خیلی زیاد باشد و از مرتبه 
:math:`|B|`
نباشد. مثلا اگر درخت ما یک مسیر باشد و 
:math:`B`
مجموعه دو راس ابتدا و انتهای این مسیر باشد
:math:`ans=n`
می شود. پس نمی توانیم از مرتبه زمانی
:math:`ans` 
هم کار کنیم.

حالا به این نکته جالب توجه کنید. حالت نهایی درخت را (که در آن راس های سیاه همبند هستند) را در نظر بگیرید و فرض کنید
درجه سیاهی هر راس مثل
:math:`u`
را تعداد راس های سیاه مجاور راس سیاه
:math:`u`
تعریف می کنیم. همانطور که احتمالا از مثالی که برای مسیر زدیم متوجه شدید، ممکن است تعداد زیادی از راس هایی که مجبور به سیاه کردنشان هستیم درجه سیاهی ۲
داشته باشند!

یک معادل سازی روی مسئله انجام می دهیم تا کارمان راحت تر شود. درخت را از یکی از راس های
:math:`B`
آویزان کنید. حالا به ازای هر راس
:math:`u`
درون
:math:`B`
تمام راس های از
:math:`u`
تا ریشه باید سیاه شوند و همچنین این سیاه بودن کافی نیز هست (یعنی ساختار به دست آمده شرط همبند بودن را دارد).

در اینجا هست که مسئله ما کمی شبیه مسئله درخت مجازی می شود.فرض کنید آنقدر به مجموعه 
:math:`B`
راس اضافه کردیم که نسبت به
LCA
بسته شد. یعنی تا زمانی که دو راس 
:math:`u, v`
درون 
:math:`B`
بودند که
LCA 
آن دو درون
:math:`B`
نبود ما باید 
LCA
این دو راس را به 
:math:`B`
اضافه کنیم.

حالا به ازای هر راس غیر از ریشه مثل 
:math:`u`
پایین ترین جد سیاهش را پدر مجازی این راس بنامید که آن را با
:math:`p_u`
نشان می دهیم. توجه کنید که حالا راس های بین
:math:`u, p_u`
همان راس هایی بودند که گفتیم درجه سیاهی آنها ۲ می شود و ممکن است تعداد آنها زیاد باشد. حالا اگر به ازای تمام
:math:`u, p_u`
هااین راس ها را بشماریم (که تعداد آن ها
:math:`h_u - h_p_u - 1`
است) و این مقدار را با تعداد راس های سیاه فعلی جمع کنیم جواب مسئله به دست خواهد آمد.

در این قسمت به چند نکته کلیدی اشاره نکردیم. از جمله اینکه:

- چطور می توانیم راس هایی را پیدا کنیم که اگر به مجموعه
:math:`B`
اضافه شوند درخت مجازی می سازند؟

- چرا تعداد حداکثر تعداد راس های درخت مجازی از 
تنها به
:math:`B`
مربوط است و ربطی به 
:math:`n`
ندارد؟

در ادامه به این سوال ها جواب می دهیم. همچنین لازم به ذکر است که سوالی که در این قسمت مطرح کردیم بدون عوض کردن ریشه هم به همان راحتی قایل حل است.
عوض کردن ریشه ای که انجام دادیم صرفا به دلیل راحت تر کردن توضیحات بود!

قطر یک زیرمجموعه
~~~~~~~~~~~~~~~~~~~~

فرض کنید یک درخت 
:math:`T`
و یک مجموعه 
:math:`B`
به شما داده اند. حالا شما باید دو تا از راس های درون 
:math:`B`
را نام ببرید که فاصله آن دو از یکدیگر بیشینه است.

الگوریتم پیدا کردن قطر درخت با 
dfs 
را در فصل ۲ بررسی کردیم. در اینجا هم اگر راس های 
:math:`B`
همبند باشند می توانیم از همان الگوریتم 
dfs 
استفاده کنیم.
اگر همبند نبود چطور؟ دغدغه فعلی ما مشابه مسئله قبلی است. یعنی می خواهیم به ازای هر دو راس 
:math:`u,v` 
از 
:math:`B`
تمام راس های حاظر در مسیر
:math:`uv`
را به 
:math:`B`
اضافه کنیم و سپس روی گراف حاصل الگوریتم 
dfs 
را اجرا کنیم.

اما در حقیقت این کار روش خوبی نیست چون همانطور که در مسئله قبل بیان کردیم ممکن است تعداد راس هایی که نیاز داریم به 
:math:`B`
خیلی زیاد باشد.

در اینجا هم مثل مسئله قبل از درخت مجازی استفاده می کنیم. یعنی مجموعه 
:math:`B`
را آنقدر بسط می دهیم تا به یک درخت مجازی برسیم.

حالا بین در یک گراف جدید بین هر راس و پدر مجازی خودش یالی با وزن 
:math:`h_u - h_p_u`
می کشیم.

حالا درخت جدیدی که داریم همان درخت مجازی ما است! با پیدا کردن قطر در این درخت، بیشینه فاصله بین راس های
:math:`B`
اولیه را پیدا می کنیم.


